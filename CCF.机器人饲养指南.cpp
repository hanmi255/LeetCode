/* 题目描述
据饲养员小 P 介绍：
机器人一天最多可以吃 m 个苹果。
一天内通过吃苹果获得的快乐值具体为：A0,A1,⋯,Am；
如果某一天饲养员共投喂机器人 i 个苹果，则这一天机器人获得的快乐值为 Ai。
特别地 A0=0，快乐值并不会凭空产生。
现在小 P 有 n 个苹果，试帮助小 P 计算：向机器人投喂这 n
个苹果能获得的最大快乐值收益。

输入格式
从标准输入读入数据。

输入共两行。

第一行包含两个整数 n 和 m，分别表示苹果总数和每天最大投喂量。

第二行依次包含
m 个整数
A1,A2,⋯,Am，表示一天内投喂不同苹果数的收益。

输出格式
输出到标准输出。

输出仅一个整数，表示投喂全部
n 个苹果能获得的最大收益。

样例1输入
10 5
1 3 5 3 1
样例1输出
16
样例1解释
一种最优投喂方案为：投喂四天，每天分别投喂 3、3、1、3 个苹果。

如该样例所示，收益序列 A
不一定单调递增，即一天内吃较多苹果可能反而获得较小快乐值。

样例2输入
4 3
1 60 100
样例2输出
120
样例2解释
一种最优投喂方案为：投喂两天，每天投喂 2 个苹果。 */

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

// 动态规划解法：计算最大价值
// 输入：
// n - 目标容量
// m - 可选物品数量
// a - 物品价值数组（索引0对应物品1的价值）
// 输出：容量n下可获得的最大价值
int main() {
    int n, m;
    cin >> n >> m;
    vector<int> a(m);
    for (int i = 0; i < m; i++) {
        cin >> a[i];
    }
    // 初始化动态规划数组，dp[i]表示容量i时的最大价值
    vector<int> dp(n + 1, 0);
    // 动态规划状态转移：遍历所有容量和物品组合
    for (int i = 1; i <= n; i++) {
        // 尝试每种物品作为最后一次选择
        for (int j = 1; j <= m; j++) {
            if (i >= j) {
                dp[i] = max(dp[i], dp[i - j] + a[j - 1]);
            }
        }
    }
    cout << dp[n] << endl;
}