/***
 * @Author: hanmi255 hanmi2550505@gmail.com
 * @Date: 2025-05-13 14:27:16
 * @LastEditTime: 2025-05-13 15:08:34
 * @LastEditors: hanmi255 hanmi2550505@gmail.com
 * @Description:
 * @FilePath: \LeetCode\miHoYo.偶网格.cpp
 * @技术宅拯救世界！！！
 */

/*
偶网格
 * 题目内容:
    有一个n行m列的网格，我们使用(i,j)表示网格中从上往下数第i行和从左往右数第j列的单元格。
    每个方格的值为0或1，且任何操作均不得超出网格边界。
    我们定义单元格的权值为该单元格与其相邻且数值不同的单元格个数。网格的奇偶性为所有单元格权值之和的奇偶性。
    Tk可以任意次进行如下操作：
     ·选择两个相邻的单元格交换它们的值
     TK想知道经过任意次操作后，能够得到多少种不同的网格为偶网格
     在这里，当|x-x`|+|y-y`|=1时，单元格(x,y)与(x`,y`)被认为是相邻的
     我们认为若两个网格至少存在一个相同位置的单元格数值不同，则认为这两个网格不同
 * 输入描述:
    第一行输入两个整数n,m(2≤n,m,n*m≤5*10^5)，表示网格的行数和列数，
    接下来输入n行，每行m个整数ai,j(ai,j可以取{0,1})，表示初始时每个单元格的值，
 * 输出描述:
    输出一个整数，表示不同偶矩阵的数量，由于答案可能很大，请将答案对10^9+7取模后输出
 * 样例1:
    输入
    2 2
    1 0
    0 1
    输出
    6
 * 说明:
    下面给出这6种不同偶矩阵的方案：
            1 0  1 0  1 1  0 1  0 1  0 0
            1 0  0 1  0 0  1 0  0 1  1 1
 * 算法思想:
    由于相邻交换可实现全局重排且权值和恒为偶，答案即为在n*m个格子中选出初始k个1分布的组合数 C(n*m,k)
*/
